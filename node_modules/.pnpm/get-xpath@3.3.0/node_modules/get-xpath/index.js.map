{"version":3,"file":"index.js","sources":["src/index.ts"],"sourcesContent":["export type Options = {\r\n    ignoreId: boolean\r\n};\r\n\r\nconst defaultOptions: Options = {\r\n    ignoreId: false\r\n};\r\n\r\nconst isNodeAvailable = typeof Node !== 'undefined';\r\n\r\nconst NodeTypes = {\r\n    ELEMENT_NODE        : isNodeAvailable ? Node.ELEMENT_NODE       : 1,\r\n    TEXT_NODE           : isNodeAvailable ? Node.TEXT_NODE          : 3,\r\n    DOCUMENT_TYPE_NODE  : isNodeAvailable ? Node.DOCUMENT_TYPE_NODE : 10\r\n};\r\n\r\n\r\nexport default function getXPath( el: any, customOptions?: Partial< Options > ): string {\r\n    const options = { ...defaultOptions, ...customOptions };\r\n    let nodeElem = el;\r\n    if ( nodeElem && nodeElem.id && ! options.ignoreId ) {\r\n        return \"//*[@id=\\\"\" + nodeElem.id + \"\\\"]\";\r\n    }\r\n    let parts: string[] = [];\r\n    while ( nodeElem && ( NodeTypes.ELEMENT_NODE === nodeElem.nodeType || NodeTypes.TEXT_NODE === nodeElem.nodeType ) ) {\r\n        let numberOfPreviousSiblings = 0;\r\n        let hasNextSiblings = false;\r\n        let sibling = nodeElem.previousSibling;\r\n        while ( sibling ) {\r\n            if ( sibling.nodeType !== NodeTypes.DOCUMENT_TYPE_NODE &&\r\n                sibling.nodeName === nodeElem.nodeName\r\n            ) {\r\n                numberOfPreviousSiblings++;\r\n            }\r\n            sibling = sibling.previousSibling;\r\n        }\r\n        sibling = nodeElem.nextSibling;\r\n        while ( sibling ) {\r\n            if ( sibling.nodeName === nodeElem.nodeName ) {\r\n                hasNextSiblings = true;\r\n                break;\r\n            }\r\n            sibling = sibling.nextSibling;\r\n        }\r\n        let prefix = nodeElem.prefix ? nodeElem.prefix + \":\" : \"\";\r\n        let nth = numberOfPreviousSiblings || hasNextSiblings\r\n            ? \"[\" + ( numberOfPreviousSiblings + 1 ) + \"]\"\r\n            : \"\";\r\n        let piece = ( nodeElem.nodeType != NodeTypes.TEXT_NODE )\r\n            ? prefix + nodeElem.localName + nth\r\n            : 'text()' + ( nth || '[1]' );\r\n\r\n        parts.push( piece );\r\n        nodeElem = nodeElem.parentNode;\r\n    }\r\n    return parts.length ? \"/\" + parts.reverse().join( \"/\" ) : \"\";\r\n}\r\n"],"names":["defaultOptions","ignoreId","isNodeAvailable","Node","NodeTypes","ELEMENT_NODE","TEXT_NODE","DOCUMENT_TYPE_NODE","el","customOptions","options","_extends","nodeElem","id","parts","nodeType","numberOfPreviousSiblings","hasNextSiblings","sibling","previousSibling","nodeName","nextSibling","nth","push","prefix","localName","parentNode","length","reverse","join"],"mappings":"uNAIA,IAAMA,EAA0B,CAC5BC,UAAU,GAGRC,EAAkC,oBAATC,KAEzBC,EACoBF,EAAkBC,KAAKE,aAAqB,EADhED,EAEoBF,EAAkBC,KAAKG,UAAqB,EAFhEF,EAGoBF,EAAkBC,KAAKI,mBAAqB,2BAIpCC,EAASC,GACvC,IAAMC,EAAOC,KAAQX,EAAmBS,GACpCG,EAAWJ,EACf,GAAKI,GAAYA,EAASC,KAAQH,EAAQT,SACtC,MAAO,YAAeW,EAASC,GAAK,KAGxC,IADA,IAAIC,EAAkB,GACdF,IAAcR,IAA2BQ,EAASG,UAAYX,IAAwBQ,EAASG,WAAa,CAIhH,IAHA,IAAIC,EAA2B,EAC3BC,GAAkB,EAClBC,EAAUN,EAASO,gBACfD,GACCA,EAAQH,WAAaX,GACtBc,EAAQE,WAAaR,EAASQ,UAE9BJ,IAEJE,EAAUA,EAAQC,gBAGtB,IADAD,EAAUN,EAASS,YACXH,GAAU,CACd,GAAKA,EAAQE,WAAaR,EAASQ,SAAW,CAC1CH,GAAkB,EAClB,MAEJC,EAAUA,EAAQG,YAEtB,IACIC,EAAMN,GAA4BC,EAChC,KAAQD,EAA2B,GAAM,IACzC,GAKNF,EAAMS,KAJQX,EAASG,UAAYX,GAJtBQ,EAASY,OAASZ,EAASY,OAAS,IAAM,IAKxCZ,EAASa,UAAYH,EAC9B,UAAaA,GAAO,QAG1BV,EAAWA,EAASc,WAExB,OAAOZ,EAAMa,OAAS,IAAMb,EAAMc,UAAUC,KAAM,KAAQ"}