"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TesterTask = void 0;
exports.getJUnitArtifactPath = getJUnitArtifactPath;
exports.getArtifactDef = getArtifactDef;
const builder_1 = require("@teambit/builder");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const compiler_1 = require("@teambit/compiler");
const dev_files_1 = __importDefault(require("@teambit/dev-files"));
const component_1 = require("@teambit/component");
const tester_1 = require("@teambit/tester");
const detect_test_files_1 = require("./detect-test-files");
const junit_generator_1 = require("./junit-generator");
function getJUnitArtifactPath() {
    return (0, path_1.join)(builder_1.CAPSULE_ARTIFACTS_DIR, '__bit_junit.xml');
}
function getArtifactDef() {
    return [
        {
            name: 'junit',
            globPatterns: [getJUnitArtifactPath()],
            rootDir: builder_1.CAPSULE_ARTIFACTS_DIR,
        },
    ];
}
/**
 * tester build task. Allows to test components during component build.
 */
class TesterTask {
    constructor(aspectId, devFiles, name = 'TestComponents', description = 'test components', tester) {
        this.aspectId = aspectId;
        this.devFiles = devFiles;
        this.name = name;
        this.description = description;
        this.tester = tester;
        this.dependencies = [compiler_1.CompilerAspect.id];
    }
    getPatterns(components, patternsWithCapsule) {
        return component_1.ComponentMap.as(components, (component) => {
            const patternEntry = patternsWithCapsule.get(component);
            // @ts-ignore
            const [, val] = patternEntry;
            return val.paths;
        });
    }
    execute(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const components = context.capsuleNetwork.originalSeedersCapsules.getAllComponents();
            const tester = this.tester || context.env.getTester();
            const componentsSpecFiles = component_1.ComponentMap.as(components, (component) => (0, detect_test_files_1.detectTestFiles)(component, this.devFiles));
            const testCount = componentsSpecFiles
                .toArray()
                .reduce((acc, [, specs]) => acc + specs.length, 0);
            if (testCount === 0) {
                return {
                    artifacts: [],
                    componentsResults: [],
                };
            }
            const compiler = context.env.getCompiler();
            if (!compiler) {
                throw new Error(`compiler not found for ${context.env.name}`);
            }
            const componentsMap = new Map();
            components.forEach((component) => {
                const componentSpecFiles = componentsSpecFiles.get(component);
                if (!componentSpecFiles)
                    throw new Error('capsule not found');
                const [, specFiles] = componentSpecFiles;
                const capsule = context.capsuleNetwork.graphCapsules.getCapsule(component.id);
                if (!capsule)
                    throw new Error('capsule not found');
                componentsMap.set(component.id.toString(), {
                    capsule,
                    specFiles,
                });
            });
            const patternsWithCapsule = component_1.ComponentMap.as(components, (component) => {
                const compMap = componentsMap.get(component.id.toString());
                // @ts-ignore. not sure why ts complain that compiler might be undefined, when we check it above.
                const distFolder = compiler.getDistDir() || compiler.distDir;
                return {
                    componentDir: (0, path_1.join)(compMap.capsule.path, distFolder),
                    paths: compMap.specFiles.map((specFile) => {
                        const distPath = compiler.getDistPathBySrcPath(specFile.relative);
                        // TODO: fix spec type file need to capsule will return files with type AbstractVinyl
                        return { path: (0, path_1.join)(compMap.capsule.path, distPath), relative: distPath };
                    }),
                };
            });
            const specFilesWithCapsule = this.getPatterns(components, patternsWithCapsule);
            const sourcePatternsWithCapsule = component_1.ComponentMap.as(components, (component) => {
                const compMap = componentsMap.get(component.id.toString());
                return {
                    componentDir: compMap.capsule.path,
                    paths: compMap.specFiles.map((specFile) => {
                        return { path: (0, path_1.join)(compMap.capsule.path, specFile.relative), relative: specFile.relative };
                    }),
                };
            });
            const sourceSpecFilesWithCapsule = this.getPatterns(components, sourcePatternsWithCapsule);
            const testerContext = Object.assign(context, {
                release: true,
                specFiles: specFilesWithCapsule,
                sourceSpecFiles: sourceSpecFilesWithCapsule,
                rootPath: context.capsuleNetwork.capsulesRootDir,
                patterns: patternsWithCapsule,
                sourcePatterns: sourcePatternsWithCapsule,
            });
            // TODO: remove after fix AbstractVinyl on capsule
            // @ts-ignore
            const testsResults = yield tester.test(testerContext);
            // write junit files
            yield Promise.all(testsResults.components.map((compResult) => __awaiter(this, void 0, void 0, function* () {
                const junit = (0, junit_generator_1.testsResultsToJUnitFormat)([compResult]);
                const capsule = context.capsuleNetwork.graphCapsules.getCapsule(compResult.componentId);
                if (!capsule) {
                    throw new Error(`unable to find ${compResult.componentId.toString()} in capsules`);
                }
                yield fs_extra_1.default.outputFile((0, path_1.join)(capsule.path, getJUnitArtifactPath()), junit);
            })));
            return {
                artifacts: getArtifactDef(), // @ts-ignore
                componentsResults: testsResults.components.map((componentTests) => {
                    var _a;
                    const componentErrors = componentTests.errors;
                    const component = (_a = context.capsuleNetwork.graphCapsules.getCapsule(componentTests.componentId)) === null || _a === void 0 ? void 0 : _a.component;
                    if (!component) {
                        throw new Error(`unable to find ${componentTests.componentId.toString()} in capsules`);
                    }
                    return {
                        component,
                        metadata: { tests: componentTests.results },
                        errors: componentErrors,
                    };
                }),
            };
        });
    }
    static from(options) {
        const name = options.name || 'tester-task';
        const handler = (context) => {
            const devFiles = context.getAspect(dev_files_1.default.id);
            const tester = options.tester(context);
            return TesterTask.create(options, { devFiles, tester });
        };
        return {
            name,
            handler,
        };
    }
    static create(options, { devFiles, tester }) {
        const name = options.name || 'tester-task';
        return new TesterTask(tester_1.TesterAspect.id, devFiles, name, options.description, tester);
    }
}
exports.TesterTask = TesterTask;
//# sourceMappingURL=tester-task.js.map