import fs from 'fs-extra';
import {
  Formatter,
  FormatterContext,
  FormatResults,
  FileFormatResult,
  ComponentFormatResult,
} from '@teambit/formatter';
import PrettierLib, { Options as PrettierModuleOptions } from 'prettier';
import { compact } from 'lodash';
import mapSeries from 'p-map-series';
import { Logger } from '@teambit/logger';
import { EnvContext, EnvHandler, ExecutionContext } from '@teambit/envs';
import { PrettierOptions } from './prettier-options';
import { computePrettierConfig } from './get-prettier-config';

// better not to import this from "teambit.component/sources", it's only used for the type here.
type AbstractVinyl = { path: string; relative: string };

const DEFAULT_EXTENSIONS = [
  '.js',
  '.jsx',
  '.ts',
  '.tsx',
  '.mjs',
  '.cjs',
  '.json',
  '.css',
  '.scss',
  '.md',
  '.mdx',
  '.html',
  '.yml',
  '.yaml',
];

export class PrettierFormatter implements Formatter {
  constructor(
    readonly id: string = 'prettier-formatter',

    private logger: Logger,

    private options: PrettierModuleOptions,

    /**
     * file types to format.
     */
    private extensions: string[] = DEFAULT_EXTENSIONS,

    /**
     * reference to the prettier module.
     */
    private prettierModule = PrettierLib
  ) {}

  // eslint-disable-next-line react/static-property-placement
  displayName = 'Prettier';

  displayConfig() {
    return JSON.stringify(this.options, null, 2);
  }

  async format(context: FormatterContext): Promise<FormatResults> {
    return this.run(context);
  }

  async formatSnippet(snippet: string, filePath?: string): Promise<string> {
    let parser;

    if (filePath) {
      const ext = filePath.split('.').pop();
      const supportInfo = await this.prettierModule.getSupportInfo();
      const language = supportInfo.languages.find((lang) => lang.extensions && lang.extensions.includes(`.${ext}`));

      if (language) {
        parser = language.parsers[0];
      }
    }

    parser = parser || 'babel';

    const optsWithFilePath = Object.assign({}, this.options, { filepath: filePath, parser });

    return this.prettierModule.format(snippet, optsWithFilePath);
  }

  async check(context: FormatterContext): Promise<FormatResults> {
    return this.run(context);
  }

  private async run(context: FormatterContext & ExecutionContext): Promise<FormatResults> {
    const check = !!context.check;
    const longProcessLogger = this.logger.createLongProcessLogger('formatting components', context.components.length);
    const resultsP = mapSeries(context.components, async (component): Promise<ComponentFormatResult> => {
      longProcessLogger.logProgress(component.id.toString());
      const filesP = component.filesystem.files.map(async (file): Promise<FileFormatResult | undefined> => {
        if (!this.extensions?.includes(file.extname)) return undefined;
        const sourceCode = file.contents.toString('utf8');
        const optsWithFilePath = this.addFilePathToOpts(this.options, file);
        const checkFormatResults = await this.prettierModule.check(sourceCode, optsWithFilePath);
        const formatResults = await this.prettierModule.format(sourceCode, optsWithFilePath);

        const hasIssues = !checkFormatResults;
        const newContent = typeof formatResults === 'string' && hasIssues ? formatResults : undefined;

        if (!check && newContent) {
          await fs.outputFile(file.path, newContent);
        }

        return {
          filePath: file.relative,
          hasIssues,
          newContent,
        };
      });

      const files = await Promise.all(filesP);

      return {
        component,
        results: compact(files),
      };
    });

    const results = await resultsP;

    return {
      results,
      errors: [],
    };
  }

  private addFilePathToOpts(options: PrettierModuleOptions, file: AbstractVinyl): PrettierModuleOptions {
    return { ...options, filepath: file.path };
  }

  version() {
    return this.prettierModule.version;
  }

  static create(options: PrettierOptions, { logger }: { logger: Logger }): Formatter {
    const name = options.name || 'prettier-formatter';
    const prettierConfig = computePrettierConfig(options);

    return new PrettierFormatter(name, logger, prettierConfig, options.extensions, options.prettier || PrettierLib);
  }

  static from(options: PrettierOptions): EnvHandler<Formatter> {
    return (context: EnvContext) => {
      const logger = context.createLogger(options.name || 'prettier-formatter');
      return PrettierFormatter.create(options, { logger });
    };
  }
}
