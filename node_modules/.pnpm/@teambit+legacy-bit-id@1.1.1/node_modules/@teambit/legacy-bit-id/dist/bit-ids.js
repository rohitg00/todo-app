"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const component_version_1 = require("@teambit/component-version");
const bit_id_1 = __importDefault(require("./bit-id"));
class BitIds extends Array {
    serialize() {
        return this.map((bitId) => bitId.toString());
    }
    has(bitId) {
        return Boolean(this.search(bitId));
    }
    hasWithoutVersion(bitId) {
        return Boolean(this.searchWithoutVersion(bitId));
    }
    hasWithoutScope(bitId) {
        return Boolean(this.searchWithoutScope(bitId));
    }
    hasWithoutScopeAndVersion(bitId) {
        return Boolean(this.searchWithoutScopeAndVersion(bitId));
    }
    hasWithoutScopeAndVersionAsString(bitIdStr) {
        return Boolean(this.find((id) => id.name === bitIdStr));
    }
    search(bitId) {
        return this.find((id) => id.hasSameName(bitId) && id.hasSameScope(bitId) && id.hasSameVersion(bitId));
    }
    searchWithoutVersion(bitId) {
        return this.find((id) => id.hasSameName(bitId) && id.hasSameScope(bitId));
    }
    searchWithoutScopeAndVersion(bitId) {
        return this.find((id) => id.hasSameName(bitId));
    }
    searchWithoutScope(bitId) {
        return this.find((id) => id.hasSameName(bitId) && id.hasSameVersion(bitId));
    }
    searchStrWithoutVersion(idStr) {
        return this.find((id) => id.toStringWithoutVersion() === idStr);
    }
    searchStrWithoutScopeAndVersion(idStr) {
        return this.find((id) => id.toStringWithoutScopeAndVersion() === idStr);
    }
    filterExact(bitId) {
        return this.filter((id) => id.hasSameName(bitId) && id.hasSameScope(bitId) && id.hasSameVersion(bitId));
    }
    filterWithoutVersion(bitId) {
        return this.filter((id) => id.hasSameName(bitId) && id.hasSameScope(bitId));
    }
    filterWithoutScopeAndVersion(bitId) {
        return this.filter((id) => id.hasSameName(bitId));
    }
    removeIfExist(bitId) {
        return BitIds.fromArray(this.filter((id) => !id.isEqual(bitId)));
    }
    /**
     * Return ids which are on the current instance and not in the passed list
     * @param bitIds
     */
    difference(bitIds) {
        return BitIds.fromArray(this.filter((id) => !bitIds.search(id)));
    }
    removeIfExistWithoutVersion(bitId) {
        return BitIds.fromArray(this.filter((id) => !id.isEqualWithoutVersion(bitId)));
    }
    removeMultipleIfExistWithoutVersion(bitIds) {
        return BitIds.fromArray(this.filter((id) => !bitIds.hasWithoutVersion(id)));
    }
    toObject() {
        return this.reduce((acc, bitId) => {
            acc[bitId.toString()] = bitId;
            return acc;
        }, {});
    }
    /**
     * make sure to pass only bit ids you know they have scope, otherwise, you'll get invalid bit ids.
     * this is mainly useful for remote commands where it is impossible to have a component without scope.
     */
    static deserialize(array = []) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return new BitIds(...array.map((id) => bit_id_1.default.parse(id, true)));
    }
    static deserializeObsolete(array = []) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return new BitIds(...array.map((id) => bit_id_1.default.parseObsolete(id)));
    }
    toString() {
        return this.map((id) => id.toString()).join(', ');
    }
    toGroupByIdWithoutVersion() {
        return this.reduce((acc, current) => {
            const idStrWithoutVer = current.toStringWithoutVersion();
            if (acc[idStrWithoutVer])
                acc[idStrWithoutVer].push(current);
            else
                acc[idStrWithoutVer] = new BitIds(current);
            return acc;
        }, {});
    }
    toGroupByScopeName(idsWithDefaultScope) {
        return this.reduce((acc, current) => {
            const getScopeName = () => {
                if (current.scope)
                    return current.scope;
                const idWithDefaultScope = idsWithDefaultScope.searchWithoutScopeAndVersion(current);
                return idWithDefaultScope ? idWithDefaultScope.scope : null;
            };
            const scopeName = getScopeName();
            if (!scopeName) {
                throw new Error(`toGroupByScopeName() expect ids to have a scope name, got ${current.toString()}`);
            }
            if (acc[scopeName])
                acc[scopeName].push(current);
            else
                acc[scopeName] = new BitIds(current);
            return acc;
        }, {});
    }
    findDuplicationsIgnoreVersion() {
        const duplications = {};
        this.forEach((id) => {
            const sameIds = this.filterWithoutVersion(id);
            if (sameIds.length > 1) {
                duplications[id.toStringWithoutVersion()] = sameIds;
            }
        });
        return duplications;
    }
    add(bitIds) {
        bitIds.forEach((bitId) => {
            if (!this.search(bitId))
                this.push(bitId);
        });
    }
    static fromObject(dependencies) {
        const array = [];
        (0, lodash_1.forEach)(dependencies, (version, id) => {
            // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
            array.push(bit_id_1.default.parse(id, true, version)); // bit.json has only imported dependencies, they all have scope
        });
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        return new BitIds(...array);
    }
    static fromArray(ids) {
        // don't do `new BitIds(...ids);`, it'll throw "Maximum call stack size exceeded" for large number if ids.
        const bitIds = new BitIds();
        ids.forEach((id) => bitIds.push(id));
        return bitIds;
    }
    static uniqFromArray(bitIds) {
        const uniq = (0, lodash_1.uniqBy)(bitIds, (id) => id.toString());
        return BitIds.fromArray(uniq);
    }
    throwForDuplicationIgnoreVersion() {
        this.forEach((bitId) => {
            const found = this.filterWithoutVersion(bitId);
            if (found.length > 1) {
                throw new Error(`bitIds has "${bitId.toStringWithoutVersion()}" duplicated as following:
${found.map((id) => id.toString()).join('\n')}`);
            }
        });
    }
    toVersionLatest() {
        return BitIds.uniqFromArray(this.map((id) => id.changeVersion(component_version_1.LATEST_VERSION)));
    }
    clone() {
        const cloneIds = this.map((id) => id.clone());
        return new BitIds(...cloneIds);
    }
}
exports.default = BitIds;
//# sourceMappingURL=bit-ids.js.map