"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const bit_id_1 = __importDefault(require("./bit-id"));
const bit_ids_1 = __importDefault(require("./bit-ids"));
describe('bitIds', () => {
    describe('uniqFromArray', () => {
        it('should return a uniq array with no duplications', () => {
            const a = new bit_id_1.default({ name: 'a' });
            const b = new bit_id_1.default({ name: 'a' });
            (0, chai_1.expect)(bit_ids_1.default.uniqFromArray([a, b])).to.have.lengthOf(1);
        });
    });
    describe('search functions', () => {
        let bitIds;
        beforeAll(() => {
            const a = new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            const b = new bit_id_1.default({ name: 'b' });
            const c = new bit_id_1.default({ name: 'c' });
            bitIds = new bit_ids_1.default(a, b, c);
        });
        describe('search', () => {
            it('should find an exact match', () => {
                const result = bitIds.search(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
            it('should find a match when an ID has only name', () => {
                const result = bitIds.search(new bit_id_1.default({ name: 'b' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'b' });
            });
            it('should not return a result with a mismatch version', () => {
                const result = bitIds.search(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.2' }));
                (0, chai_1.expect)(result).to.be.undefined;
            });
            it('should not return a result with a mismatch scope', () => {
                const result = bitIds.search(new bit_id_1.default({ name: 'a', scope: 'my-another-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.undefined;
            });
        });
        describe('searchWithoutVersion', () => {
            it('should find an exact match', () => {
                const result = bitIds.searchWithoutVersion(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
            it('should return a result even with a mismatch version', () => {
                const result = bitIds.searchWithoutVersion(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.2' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
            it('should not return a result with a mismatch scope', () => {
                const result = bitIds.searchWithoutVersion(new bit_id_1.default({ name: 'a', scope: 'my-another-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.undefined;
            });
        });
        describe('searchWithoutScopeAndVersion', () => {
            it('should find an exact match', () => {
                const result = bitIds.searchWithoutScopeAndVersion(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
            it('should return a result even with a mismatch version', () => {
                const result = bitIds.searchWithoutScopeAndVersion(new bit_id_1.default({ name: 'a', scope: 'my-scope', version: '0.0.2' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
            it('should return a result even with a mismatch scope', () => {
                const result = bitIds.searchWithoutScopeAndVersion(new bit_id_1.default({ name: 'a', scope: 'my-another-scope', version: '0.0.1' }));
                (0, chai_1.expect)(result).to.be.an.instanceOf(bit_id_1.default);
                (0, chai_1.expect)(result.serialize()).to.deep.equal({ name: 'a', scope: 'my-scope', version: '0.0.1' });
            });
        });
    });
    describe('difference', () => {
        it('should remove entries from the provided array', () => {
            const a = new bit_id_1.default({ name: 'a' });
            const b = new bit_id_1.default({ name: 'b' });
            const c = new bit_id_1.default({ name: 'c' });
            const bitIds = bit_ids_1.default.fromArray([a, b]);
            const bitIds2 = bit_ids_1.default.fromArray([b, c]);
            const res = bitIds.difference(bitIds2);
            (0, chai_1.expect)(res).to.have.lengthOf(1);
            (0, chai_1.expect)(res.serialize()[0].toString()).to.equal('a');
        });
    });
});
//# sourceMappingURL=bit-ids.spec.js.map