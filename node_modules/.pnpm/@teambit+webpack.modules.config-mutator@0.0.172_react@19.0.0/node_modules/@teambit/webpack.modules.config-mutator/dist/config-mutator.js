"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebpackConfigMutator = void 0;
const lodash_1 = require("lodash");
const webpack_merge_1 = require("webpack-merge");
const html_modules_inject_html_element_1 = require("@teambit/html.modules.inject-html-element");
__exportStar(require("webpack-merge"), exports);
const defaultAddToArrayOpts = {
    position: 'prepend',
};
const defaultAddKeyOpts = {
    conflictPolicy: 'override',
};
const defaultMergeOpts = {
    rawConfigPosition: 'prepend',
};
class WebpackConfigMutator {
    constructor(raw) {
        this.raw = raw;
    }
    clone() {
        return new WebpackConfigMutator((0, webpack_merge_1.merge)({}, this.raw));
    }
    /**
     * Add a key value to the top level config
     * @param key
     * @param value
     */
    addTopLevel(key, value, opts = {}) {
        const concreteOpts = Object.assign({}, defaultAddKeyOpts, opts);
        // eslint-disable-next-line no-prototype-builtins
        const exist = this.raw.hasOwnProperty(key);
        if (concreteOpts.conflictPolicy === 'override') {
            this.raw[key] = value;
        }
        else if (exist) {
            if (concreteOpts.conflictPolicy === 'error') {
                throw new Error(`key with name ${key} already exist in config`);
            }
        }
        else {
            this.raw[key] = value;
        }
        return this;
    }
    /**
     * Remove a key from the top level
     * @param key
     * @returns
     */
    removeTopLevel(key) {
        delete this.raw[key];
        return this;
    }
    /**
     * Add new entry to the config
     * @param entry
     * @param opts
     * @returns
     */
    addEntry(entry, opts = {}) {
        if (!this.raw.entry) {
            this.raw.entry = [];
        }
        if (!Array.isArray(this.raw.entry)) {
            throw new Error(`can't add an entry to a function type raw entry`);
        }
        this.raw.entry = addToArray(this.raw.entry, entry, opts);
        return this;
    }
    /**
     * Add rule to the module config
     * @param rule
     * @param opts
     * @returns
     */
    addModuleRule(rule, opts = {}) {
        if (!this.raw.module) {
            this.raw.module = {};
        }
        if (!this.raw.module.rules) {
            this.raw.module.rules = [];
        }
        addToArray(this.raw.module.rules, rule, opts);
        return this;
    }
    /**
     * Add many rules to the module config
     * @param rules
     * @param opts
     * @returns
     */
    addModuleRules(rules, opts = {}) {
        rules.forEach((rule) => this.addModuleRule(rule, opts));
        return this;
    }
    /** Add rule to the module config
     * @param entry
     * @param opts
     * @returns
     */
    addRuleToOneOf(rule, opts = {}) {
        if (!this.raw.module) {
            this.raw.module = {};
        }
        if (!this.raw.module.rules) {
            this.raw.module.rules = [];
        }
        // @ts-ignore
        const moduleWithOneOf = this.raw.module.rules.find((r) => !!r.oneOf);
        if (!moduleWithOneOf) {
            this.raw.module.rules.unshift({ oneOf: [] });
        }
        addToArray(moduleWithOneOf.oneOf, rule, opts);
        return this;
    }
    /**
     * Add a new plugin
     * @param plugin
     * @param opts
     * @returns
     */
    addPlugin(plugin, opts = {}) {
        if (!this.raw.plugins) {
            this.raw.plugins = [];
        }
        addToArray(this.raw.plugins, plugin, opts);
        return this;
    }
    /**
     * Add many new plugins
     * @param plugin
     * @param opts
     * @returns
     */
    addPlugins(plugins, opts = {}) {
        if (!this.raw.plugins) {
            this.raw.plugins = [];
        }
        this.raw.plugins = addManyToArray(this.raw.plugins, plugins, opts);
        return this;
    }
    /**
     * Add aliases
     * @param aliases
     * @returns
     */
    addAliases(aliases) {
        if (!this.raw.resolve) {
            this.raw.resolve = {};
        }
        if (!this.raw.resolve.alias) {
            this.raw.resolve.alias = {};
        }
        Object.assign(this.raw.resolve.alias, aliases);
        return this;
    }
    /**
     * Add aliases
     * @param aliases
     * @returns
     */
    removeAliases(aliases) {
        var _a, _b;
        if (!this.raw.resolve) {
            return this;
        }
        if (!this.raw.resolve.alias) {
            return this;
        }
        if ((0, lodash_1.isObject)((_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.alias)) {
            // @ts-ignore
            this.raw.resolve.alias = (0, lodash_1.omit)(this.raw.resolve.alias, aliases);
        }
        return this;
    }
    /**
     * Add resolve
     * @param resolve
     * @returns
     */
    addResolve(resolve) {
        if (!this.raw.resolve) {
            this.raw.resolve = {};
        }
        Object.assign(this.raw.resolve, resolve);
        return this;
    }
    /**
     * to be used to ignore replace packages with global variable
     * Useful when trying to offload libs to CDN
     * @param externalDeps
     * @returns
     */
    addExternals(externalDeps) {
        if (!externalDeps)
            return this;
        let externals = this.raw.externals;
        if (!externals) {
            externals = externalDeps;
        }
        else if (Array.isArray(externalDeps)) {
            externals = externalDeps.concat(externals);
        }
        else if (Array.isArray(externals) ||
            externalDeps.constructor === Function ||
            externalDeps.constructor === RegExp) {
            externals = [externalDeps].concat(externals);
        }
        else if (externalDeps instanceof Object && externals instanceof Object) {
            // @ts-ignore
            externals = Object.assign(Object.assign({}, externals), externalDeps);
        }
        this.raw.externals = externals;
        return this;
    }
    /**
     * Merge external configs with the current config (utilize webpack-merge)
     * @param configs
     * @param opts
     */
    merge(config, opts) {
        const configs = Array.isArray(config) ? config : [config];
        const concreteOpts = Object.assign({}, defaultMergeOpts, opts || {});
        const { firstConfig, configs: otherConfigs } = getConfigsToMerge(this.raw, configs, concreteOpts.rawConfigPosition);
        const merged = (0, webpack_merge_1.merge)(firstConfig, ...otherConfigs);
        this.raw = merged;
        return this;
    }
    /**
     * Merge external configs with the current config uses customize (array/object) function (utilize webpack-merge)
     * @param configs
     * @param customizes
     * @param opts
     * @returns
     */
    mergeWithCustomize(configs, customizes, opts) {
        const concreteOpts = Object.assign({}, defaultMergeOpts, opts);
        const { firstConfig, configs: otherConfigs } = getConfigsToMerge(this.raw, configs, concreteOpts.rawConfigPosition);
        const merged = (0, webpack_merge_1.mergeWithCustomize)(customizes)(firstConfig, ...otherConfigs);
        this.raw = merged;
        return this;
    }
    /**
     * Merge external configs with the current config uses rules (utilize webpack-merge)
     * @param configs
     * @param rules
     * @param opts
     * @returns
     */
    mergeWithRules(configs, rules, opts) {
        const concreteOpts = Object.assign({}, defaultMergeOpts, opts);
        const { firstConfig, configs: otherConfigs } = getConfigsToMerge(this.raw, configs, concreteOpts.rawConfigPosition);
        const merged = (0, webpack_merge_1.mergeWithRules)(rules)(firstConfig, ...otherConfigs);
        this.raw = merged;
        return this;
    }
    /**
     * Add PostCSS plugins
     * @param plugins
     * @returns
     * @example
     * addPostCssPlugins([require('tailwindcss')]);
     */
    addPostCssPlugins(plugins) {
        var _a, _b;
        (_b = (_a = this.raw.module) === null || _a === void 0 ? void 0 : _a.rules) === null || _b === void 0 ? void 0 : _b.forEach((rule) => {
            if (rule.use)
                processUseArray(rule.use, plugins);
            if (rule.oneOf)
                rule.oneOf.forEach((oneOfRule) => processUseArray(oneOfRule.use, plugins));
        });
        return this;
    }
    /**
     * Add a custom element to the html template
     * @param element
     * @returns
     * @example
     * addElementToHtmlTemplate({ parent: 'head', position: 'append', tag: 'script', attributes: { src: 'https://cdn.com/script.js', async: true } });
     * addElementToHtmlTemplate({ parent: 'body', position: 'prepend', tag: 'script', content: 'console.log("hello world")' });
     */
    addElementToHtmlTemplate(element) {
        var _a, _b;
        if (!this.raw.plugins) {
            this.raw.plugins = [];
        }
        const htmlPlugins = (_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.plugins) === null || _b === void 0 ? void 0 : _b.filter((plugin) => plugin.constructor.name === 'HtmlWebpackPlugin');
        if (htmlPlugins) {
            // iterate over all html plugins and add the scripts to the html
            htmlPlugins.forEach((htmlPlugin) => {
                var _a;
                const templateContent = ((_a = htmlPlugin.options) === null || _a === void 0 ? void 0 : _a.templateContent) || htmlPlugin.userOptions.templateContent;
                const htmlContent = typeof templateContent === 'function' ? templateContent({}) : templateContent;
                const newHtmlContent = (0, html_modules_inject_html_element_1.inject)(htmlContent, element);
                if (htmlPlugin.options)
                    htmlPlugin.options.templateContent = newHtmlContent;
                if (htmlPlugin.userOptions)
                    htmlPlugin.userOptions.templateContent = newHtmlContent;
            });
        }
        return this;
    }
    /**
     * Remove a custom element from the html template
     * @param element
     * @returns
     * @example
     * removeElementFromHtmlTemplate('<script>console.log("hello")</script>');
     * removeElementFromHtmlTemplate('<script src="https://example.com/script.js"></script>');
     */
    removeElementFromHtmlTemplate(element) {
        var _a, _b, _c, _d, _e;
        if (!this.raw.plugins) {
            this.raw.plugins = [];
        }
        const htmlPlugin = (_b = (_a = this.raw) === null || _a === void 0 ? void 0 : _a.plugins) === null || _b === void 0 ? void 0 : _b.find((plugin) => plugin.constructor.name === 'HtmlWebpackPlugin');
        if (htmlPlugin) {
            const htmlContent = typeof ((_c = htmlPlugin.options) === null || _c === void 0 ? void 0 : _c.templateContent) === 'function'
                ? (_d = htmlPlugin.options) === null || _d === void 0 ? void 0 : _d.templateContent({})
                : (_e = htmlPlugin.options) === null || _e === void 0 ? void 0 : _e.templateContent;
            if (htmlPlugin.options)
                htmlPlugin.options.templateContent = htmlContent.replace(element, '');
            this.raw.plugins = this.raw.plugins.map((plugin) => {
                if (plugin.constructor.name === 'HtmlWebpackPlugin') {
                    return htmlPlugin;
                }
                return plugin;
            });
        }
        return this;
    }
}
exports.WebpackConfigMutator = WebpackConfigMutator;
function processUseArray(useArray, plugins) {
    if (!useArray)
        return;
    useArray.forEach((use) => {
        if (!use.loader || !use.loader.includes('postcss-loader'))
            return;
        if (!use.options.postcssOptions)
            return;
        use.options.postcssOptions.plugins = use.options.postcssOptions.plugins || [];
        use.options.postcssOptions.plugins.unshift(...plugins);
    });
}
function getConfigsToMerge(originalConfig, configs, originalPosition) {
    let firstConfig = originalConfig;
    if (originalPosition === 'append') {
        firstConfig = configs.shift() || {};
        configs.push(originalConfig);
    }
    return {
        firstConfig,
        configs,
    };
}
function addToArray(array, val, opts = {}) {
    const concreteOpts = Object.assign({}, defaultAddToArrayOpts, opts);
    if (concreteOpts.position === 'prepend') {
        array === null || array === void 0 ? void 0 : array.unshift(val);
    }
    else {
        array === null || array === void 0 ? void 0 : array.push(val);
    }
    return array;
}
function addManyToArray(array, vals, opts = {}) {
    const concreteOpts = Object.assign({}, defaultAddToArrayOpts, opts);
    if (concreteOpts.position === 'prepend') {
        // array = array?.concat(vals);
        array === null || array === void 0 ? void 0 : array.unshift(...vals);
    }
    else {
        // array = vals?.concat(array);
        array === null || array === void 0 ? void 0 : array.push(...vals);
    }
    return array;
}
//# sourceMappingURL=config-mutator.js.map