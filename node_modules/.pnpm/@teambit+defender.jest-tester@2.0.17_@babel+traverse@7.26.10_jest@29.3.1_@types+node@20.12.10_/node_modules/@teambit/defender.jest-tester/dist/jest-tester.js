"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JestTester = exports.jestWorkerPath = void 0;
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const normalize_path_1 = __importDefault(require("normalize-path"));
const minimatch_1 = __importDefault(require("minimatch"));
const lodash_1 = require("lodash");
const comlink_1 = require("comlink");
const tester_1 = require("@teambit/tester");
const tests_results_1 = require("@teambit/tests-results");
const jest_message_util_1 = require("jest-message-util");
const component_1 = require("@teambit/component");
const jest_error_1 = require("./jest-error");
exports.jestWorkerPath = require.resolve('./jest.worker');
const DEFAULT_NAME = 'jest-tester';
class JestTester {
    constructor(id, jestConfig, jestModulePath = require.resolve('jest'), jestWorker, logger, opts = {}) {
        this.id = id;
        this.jestConfig = jestConfig;
        this.jestModulePath = jestModulePath;
        this.jestWorker = jestWorker;
        this.logger = logger;
        this.opts = opts;
        this.configPath = this.jestConfig;
        // eslint-disable-next-line react/static-property-placement
        this.displayName = 'Jest';
        // eslint-disable-next-line global-require,import/no-dynamic-require
        this.jestModule = require(jestModulePath);
    }
    displayConfig() {
        return (0, fs_extra_1.readFileSync)(this.jestConfig, 'utf8');
    }
    version() {
        return this.jestModule.getVersion();
    }
    attachTestsToComponent(testerContext, testResult) {
        return component_1.ComponentMap.as(testerContext.components, (component) => {
            // TODO: remove this ts-ignore once we have updated the TesterContext on bit
            // @ts-ignore
            const patterns = this.opts.useSourceFiles ? testerContext.sourcePatterns : testerContext.patterns;
            const componentPatternValue = patterns.get(component);
            if (!componentPatternValue)
                return undefined;
            const [currComponent, patternEntry] = componentPatternValue;
            const resolvedPatterns = this.resolveComponentPattern(currComponent, patternEntry, testerContext);
            return testResult.filter((test) => resolvedPatterns.some((resolvedPattern) => (0, minimatch_1.default)(test.testFilePath, resolvedPattern) ||
                // on Windows, `test.testFilePath` has only single black slashes, while `resolvedPattern` has double black slashes.
                (0, minimatch_1.default)((0, normalize_path_1.default)(test.testFilePath), (0, normalize_path_1.default)(resolvedPattern))));
        });
    }
    buildTestsObj(aggregatedResult, components, testerContext, config) {
        const testsSuiteResult = components.toArray().map(([component, testsFiles]) => {
            if (!testsFiles)
                return undefined;
            if ((testsFiles === null || testsFiles === void 0 ? void 0 : testsFiles.length) === 0)
                return undefined;
            const errors = this.getErrors(testsFiles);
            const tests = testsFiles.map((test) => {
                const testResults = test.testResults.map((testResult) => {
                    const error = (0, jest_message_util_1.formatResultsErrors)([testResult], config, {
                        noStackTrace: true,
                    }) || undefined;
                    const isFailure = testResult.status === 'failed';
                    return new tests_results_1.TestResult(testResult.ancestorTitles, testResult.title, testResult.status, testResult.duration, isFailure ? undefined : error, isFailure ? error : undefined);
                });
                const filePath = (0, path_1.basename)(test.testFilePath);
                const getError = () => {
                    var _a, _b;
                    if (!test.testExecError)
                        return undefined;
                    if (testerContext.watch) {
                        // for some reason, during watch ('bit start'), if a file has an error, the `test.testExecError` is `{}`
                        // (an empty object). the failureMessage contains the stringified error.
                        // @todo: consider to always use the failureMessage, regardless the context.watch.
                        return new jest_error_1.JestError(test.failureMessage);
                    }
                    return new jest_error_1.JestError((_a = test.testExecError) === null || _a === void 0 ? void 0 : _a.message, (_b = test.testExecError) === null || _b === void 0 ? void 0 : _b.stack);
                };
                const error = getError();
                return new tests_results_1.TestsFiles(filePath, testResults, test.numPassingTests, test.numFailingTests, test.numPendingTests, test.perfStats.runtime, test.perfStats.slow, error);
            });
            return {
                componentId: component.id,
                results: new tests_results_1.TestsResult(tests, aggregatedResult.success, aggregatedResult.startTime),
                errors,
            };
        });
        return (0, lodash_1.compact)(testsSuiteResult);
    }
    getErrors(testResult) {
        return testResult.reduce((errors, test) => {
            if (test.testExecError) {
                const { message, stack, code, type } = test.testExecError;
                errors.push(new jest_error_1.JestError(message, stack, code, type));
            }
            else if (test.failureMessage) {
                errors.push(new jest_error_1.JestError(test.failureMessage));
            }
            return errors;
        }, []);
    }
    onTestRunComplete(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            this._callback = callback;
        });
    }
    customizeJestConfig(jestConfig, context) {
        const snapshotResolverPath = context.release && !this.opts.useSourceFiles ?
            require.resolve('./config/custom-resolver/snapshotResolverBuild.js')
            : require.resolve('./config/custom-resolver/snapshotResolverLocal.js');
        const testIgnoreRegex = '^.*__snapshots__.*.spec.*';
        const testMatchPatterns = [...this.patternsToArray(context)];
        const config = Object.assign(jestConfig, {
            testMatch: testMatchPatterns,
            snapshotResolver: snapshotResolverPath,
            testPathIgnorePatterns: [...(jestConfig.testPathIgnorePatterns || []), testIgnoreRegex],
        });
        if (this.opts.useSourceFiles) {
            config.testPathIgnorePatterns.push('dist/*');
            config.resolver = require.resolve('./config/custom-resolver/resolver.js');
        }
        return config;
    }
    test(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // const envRootDir = context.envRuntime.envAspectDefinition.aspectPath;
            const config = {
                // Setting the rootDir to the env root dir to make sure we can resolve all the jest presets/plugins
                // from the env context
                // rootDir: envRootDir,
                // TODO: set it to envRootDir and make sure we can make the --coverage to work
                // with the current value as context.rootPath it will probably won't work correctly when using rootComponents:true (maybe even won't work at all)
                // TODO: when changing to envRootDir we have some issues with the react-native tests. so once changed again, it needs to be validated.
                rootDir: context.rootPath,
                // Setting the roots (where to search for spec files) to the root path (either workspace or capsule root)
                // TODO: consider change this to be an array of the components running dir.
                // TODO: aka: in the workspace it will be something like <ws>/node_modules/<comp-package-name>/node_modules/<comp-package-name>
                // TODO: see dependencyResolver.getRuntimeModulePath (this will make sure the peer deps resolved correctly)
                // TODO: (@GiladShoham - when trying to set it to this paths, jest ignores it probably because the paths contains "node_modules"
                // TODO: trying to set the https://jestjs.io/docs/27.x/configuration#testpathignorepatterns-arraystring to something else (as it contain node_modules by default)
                // TODO: didn't help)
                roots: [context.rootPath],
            };
            // eslint-disable-next-line no-console
            console.warn = (message) => {
                this.logger.warn(message);
            };
            if (context.debug) {
                config.debug = true;
                // config.runInBand = true;
            }
            if (context.coverage)
                config.coverage = true;
            // config.runInBand = true;
            if (context.watch) {
                config.watchAll = true;
                config.noCache = true;
            }
            // TODO: remove the any type later (https://github.com/teambit/bit/pull/9025)
            if (context.updateSnapshot) {
                config.updateSnapshot = true;
            }
            // eslint-disable-next-line global-require,import/no-dynamic-require
            const jestConfig = require(this.jestConfig);
            // TODO: rollback this for now, as it makes issues.
            // TODO: it's mostly relevant for when the root components feature is enabled.
            // TODO: we might want to enable it only on that case (along with setting the env root dir as the root dir, above)
            // const moduleNameMapper = await this.calculateModuleNameMapper(
            //   context.env,
            //   context.rootPath,
            //   context.additionalHostDependencies
            // );
            // jestConfig.moduleNameMapper = Object.assign({}, jestConfig.moduleNameMapper || {}, moduleNameMapper);
            const jestConfigCustomized = this.customizeJestConfig(jestConfig, context);
            const withEnv = Object.assign(jestConfigCustomized, config);
            const testsOutPut = yield this.jestModule.runCLI(withEnv, [this.jestConfig]);
            const { testResults } = testsOutPut.results;
            const componentsWithTests = this.attachTestsToComponent(context, testResults);
            const componentTestResults = this.buildTestsObj(testsOutPut.results, componentsWithTests, context, jestConfigCustomized);
            return new tester_1.Tests(componentTestResults);
        });
    }
    watch(context) {
        return __awaiter(this, void 0, void 0, function* () {
            // eslint-disable-next-line
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const workerApi = this.jestWorker.initiate(context.ui ? { stdout: true, stderr: true, stdin: true } : { stdout: false, stderr: false, stdin: false });
                // eslint-disable-next-line
                const jestConfig = require(this.jestConfig);
                const envRootDir = (_a = context.envRuntime.envAspectDefinition) === null || _a === void 0 ? void 0 : _a.aspectPath;
                if (!envRootDir) {
                    this.logger.warn(`jest tester, envRootDir is not defined, for env ${context.envRuntime.id}`);
                }
                const jestConfigCustomized = this.customizeJestConfig(jestConfig, context);
                try {
                    const cbFn = (0, comlink_1.proxy)((results) => {
                        if (!this._callback)
                            return;
                        const { testResults } = results;
                        const componentsWithTests = this.attachTestsToComponent(context, testResults);
                        const componentTestResults = this.buildTestsObj(results, componentsWithTests, context, jestConfigCustomized);
                        const globalErrors = this.getErrors(testResults);
                        const watchTestResults = {
                            loading: false,
                            errors: globalErrors,
                            components: componentTestResults,
                        };
                        this._callback(watchTestResults);
                        resolve(watchTestResults);
                    });
                    // eslint-disable-next-line @typescript-eslint/no-floating-promises
                    yield workerApi.onTestComplete(cbFn);
                    yield workerApi.watch(this.jestConfig, this.patternsToArray(context), context.rootPath, this.jestModulePath, envRootDir);
                }
                catch (err) {
                    this.logger.error('jest.tester.watch() caught an error', err);
                }
            }));
        });
    }
    // private async calculateModuleNameMapper(
    //   env: Environment,
    //   rootPath: string,
    //   additionalHostDependencies?: string[]
    // ): Promise<Record<string, Array<string>>> {
    //   const peerDepsConfig: EnvPolicyConfigObject = await env.getDependencies();
    //   const peersAutoDetectPolicy = new PeersAutoDetectPolicy(peerDepsConfig.peers || []);
    //   const peers = Object.keys(peerDepsConfig.peerDependencies || {}).concat(peersAutoDetectPolicy?.names);
    //   const depsToMap = peers.concat(additionalHostDependencies || []);
    //   /**
    //    * Try to resolve the dependency from the rootDir (the env dir) or from the root path (workspace/capsule root)
    //    */
    //   const mappedValues = ['<rootDir>/node_modules/$1', `${rootPath}/node_modules/$1`];
    //   const moduleNameMapper = depsToMap.reduce((acc, peerName) => {
    //     const keyName = `^(${peerName})$`;
    //     acc[keyName] = mappedValues;
    //     const internalPathKeyName = `^(${peerName}/.*)$`;
    //     acc[internalPathKeyName] = mappedValues;
    //     return acc;
    //   }, {});
    //   return moduleNameMapper;
    // }
    patternsToArray(context) {
        // TODO: remove this ts-ignore once we have updated the TesterContext on bit
        // @ts-ignore
        const patterns = this.opts.useSourceFiles ? context.sourcePatterns : context.patterns;
        return (0, lodash_1.flatten)(patterns
            .toArray()
            .map(([component, patternEntry]) => this.resolveComponentPattern(component, patternEntry, context)));
    }
    resolveComponentPattern(component, patternEntry, context) {
        if (this.opts.resolveSpecPaths) {
            return this.opts.resolveSpecPaths(component, context);
        }
        const customPatterns = this.opts.patterns;
        // If patterns were provided to the specific instance of the tester, use them
        if (customPatterns && !(0, lodash_1.isEmpty)(customPatterns)) {
            customPatterns.map((customPattern) => {
                const rootDirs = this.opts.roots || [patternEntry.componentDir];
                return this.resolvePattern(customPattern, rootDirs);
            });
        }
        const paths = [];
        patternEntry.paths.forEach((p) => {
            if (p.relative.startsWith('!')) {
                paths.push(`!${(0, path_1.resolve)(patternEntry.componentDir, p.relative.slice(1))}`);
            }
            else {
                if (p.relative.includes('!')) {
                    this.logger.consoleWarning(`Negation patterns only work in jest if they start with "!", the glob "${p.relative}" will not work as expected`);
                }
                paths.push(p.path);
            }
        });
        return paths;
    }
    resolvePattern(pattern, rootDirs) {
        return rootDirs.map((dir) => (0, path_1.resolve)(dir, pattern));
    }
    static create(options, { logger, worker }) {
        const id = options.name || DEFAULT_NAME;
        return new JestTester(id, options.config, options.jest, worker, logger, options);
    }
    static from(options) {
        const id = options.name || DEFAULT_NAME;
        return (context) => {
            const logger = context.createLogger(id);
            const worker = context.createWorker(id, exports.jestWorkerPath);
            return JestTester.create(options, { logger, worker });
        };
    }
}
exports.JestTester = JestTester;
//# sourceMappingURL=jest-tester.js.map