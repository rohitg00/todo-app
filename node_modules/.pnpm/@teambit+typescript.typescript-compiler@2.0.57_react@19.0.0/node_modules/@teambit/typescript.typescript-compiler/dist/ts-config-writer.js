"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptConfigWriter = exports.GLOBAL_TYPES_DIR = void 0;
// import findRoot from 'find-root';
const normalize_path_1 = __importDefault(require("normalize-path"));
const comment_json_1 = require("comment-json");
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = require("path");
const lodash_1 = require("lodash");
const expand_include_exclude_1 = require("./expand-include-exclude");
const get_ts_config_1 = require("./get-ts-config");
const resolve_types_1 = require("./resolve-types");
const CONFIG_NAME = 'tsconfig.json';
const BIT_GENERATED_TS_CONFIG_COMMENT = '// bit-generated-typescript-config';
exports.GLOBAL_TYPES_DIR = 'global-types';
const sha1 = (str) => crypto_1.default.createHash('sha1').update(str).digest('hex');
class TypescriptConfigWriter {
    constructor(name, tsconfig, typesPaths = [], logger, options) {
        this.name = name;
        this.tsconfig = tsconfig;
        this.typesPaths = typesPaths;
        this.logger = logger;
        this.options = options;
        this.id = 'typescript';
        this.patterns = [`**/${CONFIG_NAME}`];
    }
    // @ts-ignore - temporary until we released new bit version with https://github.com/teambit/bit/pull/8615
    calcConfigFiles(_executionContext, envMapValue, configsRootDir, workspaceDir) {
        var _a, _b;
        const tsConfigContent = JSON.stringify(this.tsconfig, null, 2);
        // It's important to calculate the hash before we call the expandIncludeExclude function
        // to make sure we get the same hash for the same config.
        // we will merge different include/exclude patterns to the same config file as part of the mergeConfigFiles
        // below
        const tsConfigHash = sha1(tsConfigContent);
        const tsConfigName = `tsconfig.bit.${tsConfigHash}.json`;
        const tsConfigPath = (0, path_1.join)(configsRootDir, tsConfigName);
        const tsConfigCloned = JSON.parse(tsConfigContent);
        const compDirs = envMapValue.paths;
        const newTsConfig = (0, expand_include_exclude_1.expandIncludeExclude)(tsConfigPath, tsConfigCloned, compDirs, exports.GLOBAL_TYPES_DIR);
        // probably not needed. it converts the types to be absolute paths. it breaks the types.
        // see https://www.typescriptlang.org/tsconfig/#types it should resolve the types automatically
        // this.resolveCompilerOptions(newTsConfig, workspaceDir);
        this.addRootDir(newTsConfig, configsRootDir, workspaceDir);
        // probably not needed as well. this one changes the path to be relative to the tsconfig file. it breaks the types.
        // if (newTsConfig.compilerOptions?.types) {
        //   newTsConfig.compilerOptions.types = this.resolveGlobalTypes(newTsConfig.compilerOptions.types, configsRootDir, workspaceDir);
        // }
        if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.paths) {
            this.addPaths(newTsConfig, this.options.paths);
        }
        if ((_b = this.options) === null || _b === void 0 ? void 0 : _b.includes) {
            this.addIncludes(newTsConfig, this.options.includes);
        }
        const newTsConfigContent = JSON.stringify(newTsConfig, null, 2);
        const typescriptConfigFile = {
            content: newTsConfigContent,
            hash: tsConfigHash,
            name: tsConfigName,
        };
        const globalTypesConfigFiles = this.getGlobalTypesConfigFiles(this.typesPaths);
        return [typescriptConfigFile, ...globalTypesConfigFiles];
    }
    // private resolveGlobalTypes(typesNames: string[] = [], configsRootDir: string, workspaceDir: string) {
    //   const allResolved = typesNames.map((name) => {
    //     // No need to change relative or paths without slash (which is usually a package name)
    //     if (name.startsWith('.') || !name.includes('/')) {
    //       return name;
    //     }
    //     try {
    //       const packageName = name.startsWith('@') ? name : name.split('/')[0];
    //       const internalPackagePath = name.replace(packageName, '');
    //       const internalPackagePathWithoutSlash = internalPackagePath.startsWith('/')
    //         ? internalPackagePath.slice(1)
    //         : internalPackagePath;
    //       const resolved = require.resolve(packageName, { paths: [workspaceDir] });
    //       const packageRoot = findRoot(resolved);
    //       const relativePath = relative(configsRootDir, packageRoot);
    //       const relativeWithoutTrailSlash = relativePath.endsWith('/') ? relativePath.slice(0, -1) : relativePath;
    //       const result = internalPackagePathWithoutSlash ? `${relativePath}/${internalPackagePathWithoutSlash}` : relativeWithoutTrailSlash;
    //       return result;
    //     } catch (e) {
    //       this.logger.error(`failed to resolve global type ${name}`);
    //       return name;
    //     }
    //   });
    //   return allResolved;
    // }
    // private resolveCompilerOptions(tsConfig: TsConfigJson, workspaceDir: string) {
    //   if (tsConfig.compilerOptions && tsConfig.compilerOptions.types) {
    //     // eslint-disable-next-line no-param-reassign
    //     tsConfig.compilerOptions.types = tsConfig.compilerOptions.types.map((type) => {
    //       // absolute path
    //       if (isAbsolute(type)) return type;
    //       // relative path
    //       if (type[0] === '.') return resolve(workspaceDir, type);
    //       // node_modules
    //       return resolve(workspaceDir, 'node_modules', type);
    //     });
    //   }
    // }
    addRootDir(tsConfig, configsRootDir, workspaceDir) {
        let wsDir = workspaceDir;
        const normalizedConfigRootDir = (0, normalize_path_1.default)(configsRootDir);
        if (!wsDir) {
            const nmIndex = normalizedConfigRootDir.indexOf('node_modules');
            if (nmIndex > -1) {
                wsDir = normalizedConfigRootDir.substring(0, nmIndex);
            }
        }
        if (!wsDir)
            return;
        const rootDir = (0, normalize_path_1.default)((0, path_1.relative)(configsRootDir, wsDir));
        tsConfig.compilerOptions = tsConfig.compilerOptions || {};
        tsConfig.compilerOptions.rootDir = rootDir;
    }
    addPaths(tsConfig, paths) {
        // Ensure tsConfig.compilerOptions and paths are initialized
        const compilerOptions = (tsConfig.compilerOptions = tsConfig.compilerOptions || {});
        const tsPaths = (compilerOptions.paths = compilerOptions.paths || {});
        Object.keys(paths).forEach((key) => {
            if (!tsPaths[key]) {
                tsPaths[key] = paths[key];
            }
            else {
                tsPaths[key].push(...paths[key]);
            }
        });
    }
    addIncludes(tsConfig, includes) {
        // Ensure tsConfig.include is initialized
        const includeList = (tsConfig.include = tsConfig.include || []);
        includes.forEach((include) => {
            if (!includeList.includes(include)) {
                includeList.push(include);
            }
        });
    }
    getGlobalTypesConfigFiles(typesPaths = []) {
        const files = typesPaths.map((path) => {
            const content = fs_extra_1.default.readFileSync(path).toString();
            const origName = (0, path_1.basename)(path);
            const nameWithHash = origName.replace(/\.d\.ts$/, '.{hash}.d.ts');
            const name = `${exports.GLOBAL_TYPES_DIR}/${nameWithHash}`;
            return {
                content,
                name,
            };
        });
        return files;
    }
    mergeConfigFiles(configFile, configFile2) {
        // Only merge tsconfig files (not global types for example)
        if (!configFile.name.includes('tsconfig.bit')) {
            return configFile.content;
        }
        const tsConfig1 = (0, comment_json_1.parse)(configFile.content);
        const tsConfig2 = (0, comment_json_1.parse)(configFile2.content);
        // @ts-ignore
        tsConfig1.include = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.include) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.include) || [])]).sort();
        // @ts-ignore
        tsConfig1.exclude = (0, lodash_1.uniq)([...((tsConfig1 === null || tsConfig1 === void 0 ? void 0 : tsConfig1.exclude) || []), ...((tsConfig2 === null || tsConfig2 === void 0 ? void 0 : tsConfig2.exclude) || [])]).sort();
        const content = (0, comment_json_1.stringify)(tsConfig1, null, 2);
        return content;
    }
    generateExtendingFile(args) {
        const { writtenConfigFiles } = args;
        const tsconfigFile = writtenConfigFiles.find((file) => file.name.includes('tsconfig.bit'));
        if (!tsconfigFile)
            return undefined;
        const config = {
            // Using DSL to make sure it will be replaced with relative path
            extends: `{${tsconfigFile.name}}`,
        };
        const content = `${BIT_GENERATED_TS_CONFIG_COMMENT}\n\n${JSON.stringify(config, null, 2)}`;
        return { content, name: 'tsconfig.json', extendingTarget: tsconfigFile, useAbsPaths: false };
    }
    postProcessExtendingConfigFiles(args) {
        return __awaiter(this, void 0, void 0, function* () {
            // const { workspaceDir, configsRootDir, paths, extendingConfigFile, supportSpecificPathChange } = args;
            // @ts-ignore - ignore here is for backward compatibility as supportSpecificPathChange didn't exist in the past
            const { paths, extendingConfigFile, supportSpecificPathChange } = args;
            // Only run for the root tsconfig.json
            if (!paths.find((path) => path === '.')) {
                return undefined;
            }
            const { content } = extendingConfigFile;
            const tsConfig = (0, comment_json_1.parse)(content);
            // @ts-ignore
            const compilerOptions = tsConfig.compilerOptions || {};
            // seems like there is no need to add the typeRoots of the global-types as they're already added to the "include"
            // prop of the tsconfig.json. If it's there, it breaks the types in some places.
            // const typeRoots = compilerOptions.typeRoots || [];
            // const globalTypesDir = join(configsRootDir, GLOBAL_TYPES_DIR);
            // const relativeGlobalTypesDir = normalize(`./${relative(workspaceDir, globalTypesDir)}`);
            // typeRoots.push(relativeGlobalTypesDir);
            // typeRoots.push('./node_modules/@types');
            // assign(compilerOptions, { typeRoots: uniq(typeRoots) });
            (0, comment_json_1.assign)(tsConfig, { compilerOptions });
            const newContent = (0, comment_json_1.stringify)(tsConfig, null, 2);
            if (supportSpecificPathChange) {
                // @ts-ignore - ignore here is for backward compatibility as this was invalid result type in old version
                return [
                    {
                        path: '.',
                        content: newContent,
                    },
                ];
            }
            // For backward compatibility
            return newContent;
        });
    }
    isBitGenerated(filePath) {
        const content = fs_extra_1.default.readFileSync(filePath).toString();
        return content.includes(BIT_GENERATED_TS_CONFIG_COMMENT);
    }
    static from(options) {
        const name = options.name || 'TypescriptConfigWriter';
        const handler = (context) => {
            return TypescriptConfigWriter.create(options, context.createLogger(name));
        };
        return {
            name,
            // @ts-ignore - temporary until we released new bit version with https://github.com/teambit/bit/pull/8615
            handler,
        };
    }
    static create(options, logger) {
        const name = options.name || 'TypescriptConfigWriter';
        const rawTsConfig = (0, get_ts_config_1.computeTsConfig)({
            tsconfig: options.tsconfig,
            compilerOptions: options.compilerOptions,
        });
        const types = options.types || (0, resolve_types_1.resolveTypes)(__dirname, ['global-types']);
        return new TypescriptConfigWriter(name, rawTsConfig, types, logger, options.options);
    }
}
exports.TypescriptConfigWriter = TypescriptConfigWriter;
//# sourceMappingURL=ts-config-writer.js.map