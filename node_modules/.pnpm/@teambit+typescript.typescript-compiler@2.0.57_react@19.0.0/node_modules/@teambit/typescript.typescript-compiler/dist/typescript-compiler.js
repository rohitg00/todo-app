"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypescriptCompiler = void 0;
const normalize_path_1 = __importDefault(require("normalize-path"));
const glob_1 = require("glob");
const typescript_1 = __importDefault(require("typescript"));
const lodash_1 = require("lodash");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importStar(require("path"));
const bit_error_1 = require("@teambit/bit-error");
const get_ts_config_1 = require("./get-ts-config");
const resolve_types_1 = require("./resolve-types");
class TypescriptCompiler {
    constructor(id = 'typescript-compiler', logger, options, rawTsConfig, tsModule) {
        var _a, _b;
        var _c, _d, _e;
        this.id = id;
        this.logger = logger;
        this.options = options;
        this.rawTsConfig = rawTsConfig;
        this.tsModule = tsModule;
        // eslint-disable-next-line react/static-property-placement
        this.displayName = 'TypeScript';
        this.deleteDistDir = false;
        this.distDir = options.distDir || 'dist';
        this.distGlobPatterns = options.distGlobPatterns || [
            `${this.distDir}/**`,
            `!${this.distDir}/tsconfig.tsbuildinfo`,
            `!${this.distDir}/tsconfig.json`,
        ];
        this.shouldCopyNonSupportedFiles =
            typeof options.shouldCopyNonSupportedFiles === 'boolean'
                ? options.shouldCopyNonSupportedFiles
                : true;
        this.artifactName = options.artifactName || 'dist';
        this.rawTsConfig || (this.rawTsConfig = {});
        (_c = this.rawTsConfig).compilerOptions || (_c.compilerOptions = {});
        // mutate the outDir, otherwise, on capsules, the dists might be written to a different directory and make confusion
        this.rawTsConfig.compilerOptions.outDir = this.distDir;
        this.options.types = this.options.types || this.getDefaultGlobalTypes();
        (_a = (_d = this.options).compileJs) !== null && _a !== void 0 ? _a : (_d.compileJs = true);
        (_b = (_e = this.options).compileJsx) !== null && _b !== void 0 ? _b : (_e.compileJsx = true);
    }
    /**
     * get the computed tsconfig for the instance.
     * TODO: @gilad support transformers here.
     */
    get tsconfig() {
        return this.rawTsConfig;
    }
    displayConfig() {
        return this.stringifyTsconfig(this.tsconfig);
    }
    getDistDir() {
        return this.distDir;
    }
    preGenerateTypesOnWorkspace(params, envId) {
        return __awaiter(this, void 0, void 0, function* () {
            const customTsconfig = Object.assign({}, this.rawTsConfig);
            customTsconfig.compilerOptions = customTsconfig.compilerOptions || {};
            customTsconfig.compilerOptions.composite = true;
            yield Promise.all(params.map((param) => __awaiter(this, void 0, void 0, function* () {
                yield fs_extra_1.default.writeFile(path_1.default.join(param.packageDir, 'tsconfig.json'), this.stringifyTsconfig(customTsconfig));
            })));
            yield this.writeTypes(params.map((param) => param.packageDir), envId);
        });
    }
    createHost(currentComponentResult) {
        const formatHost = {
            getCanonicalFileName: (p) => p,
            getCurrentDirectory: () => '', // it helps to get the files with absolute paths
            getNewLine: () => this.tsModule.sys.newLine,
        };
        const reportDiagnostic = (diagnostic) => {
            const errorStr = process.stdout.isTTY
                ? this.tsModule.formatDiagnosticsWithColorAndContext([diagnostic], formatHost)
                : this.tsModule.formatDiagnostic(diagnostic, formatHost);
            if (!diagnostic.file) {
                // the error is general and not related to a specific file. e.g. tsconfig is missing.
                throw new bit_error_1.BitError(errorStr);
            }
            this.logger.consoleFailure(errorStr);
            if (!currentComponentResult.component || !currentComponentResult.errors) {
                throw new Error(`currentComponentResult is not defined yet for ${diagnostic.file}`);
            }
            currentComponentResult.errors.push(errorStr);
        };
        // this only works when `verbose` is `true` in the `ts.createSolutionBuilder` function.
        const reportSolutionBuilderStatus = (diag) => {
            const msg = diag.messageText;
            this.logger.debug(msg);
        };
        const errorCounter = (errorCount) => {
            this.logger.info(`total error found: ${errorCount}`);
        };
        const host = this.tsModule.createSolutionBuilderHost(undefined, undefined, reportDiagnostic, reportSolutionBuilderStatus, errorCounter);
        return host;
    }
    generateTypesOnWorkspace(rootDir, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentsResults = [];
            let currentComponentResult = { errors: [] };
            const host = this.createHost(currentComponentResult);
            const packageDirs = params.map((param) => param.packageDir);
            yield this.writeProjectReferencesTsConfig(rootDir, packageDirs);
            const solutionBuilder = this.tsModule.createSolutionBuilder(host, [rootDir], { verbose: true });
            let nextProject;
            const longProcessLogger = this.logger.createLongProcessLogger('compile typescript components', packageDirs.length);
            // eslint-disable-next-line no-cond-assign
            while ((nextProject = solutionBuilder.getNextInvalidatedProject())) {
                // regex to make sure it will work correctly for both linux and windows
                const packagePath = nextProject.project.replace(/[/\\]tsconfig.json/, '');
                const foundParam = params.find((param) => param.packageDir === packagePath);
                if (!foundParam)
                    throw new Error(`generateTypesOnWorkspace: unable to find params for ${packagePath}`);
                longProcessLogger.logProgress(foundParam.component.id.toString());
                currentComponentResult.component = foundParam.component;
                currentComponentResult.startTime = Date.now();
                nextProject.done(undefined, undefined, this.options.typescriptTransformers);
                currentComponentResult.endTime = Date.now();
                componentsResults.push(Object.assign({}, currentComponentResult));
                currentComponentResult = { errors: [] };
            }
            longProcessLogger.end();
            if (!componentsResults.length) {
                solutionBuilder.build();
            }
        });
    }
    /**
     * compile one file on the workspace
     */
    transpileFile(fileContent, options) {
        if (!this.isFileSupported(options.filePath)) {
            return null; // file is not supported
        }
        const compilerOptionsFromTsconfig = this.tsModule.convertCompilerOptionsFromJson(this.rawTsConfig.compilerOptions, '.');
        if (compilerOptionsFromTsconfig.errors.length) {
            // :TODO @david replace to a more concrete error type and put in 'exceptions' directory here.
            const formattedErrors = this.tsModule.formatDiagnosticsWithColorAndContext(compilerOptionsFromTsconfig.errors, this.getFormatDiagnosticsHost());
            throw new Error(`failed parsing the tsconfig.json.\n${formattedErrors}`);
        }
        const compilerOptions = compilerOptionsFromTsconfig.options;
        compilerOptions.sourceRoot = options.componentDir;
        compilerOptions.rootDir = '.';
        const typescriptTransformers = this.options.typescriptTransformers || {};
        // const fileName = this.getFilePathForTranspileFile(options.filePath);
        if (this.options.esm) {
            compilerOptions.module = this.tsModule.ModuleKind.ESNext;
            compilerOptions.moduleResolution =
                this.tsModule.ModuleResolutionKind.Node10;
        }
        const fileName = options.filePath;
        const result = this.tsModule.transpileModule(fileContent, {
            compilerOptions,
            fileName,
            reportDiagnostics: true,
            transformers: typescriptTransformers,
        });
        if (result.diagnostics && result.diagnostics.length) {
            const formatHost = this.getFormatDiagnosticsHost();
            const error = this.tsModule.formatDiagnosticsWithColorAndContext(result.diagnostics, formatHost);
            throw new Error(error);
        }
        const outputPath = this.replaceFileExtToJs(options.filePath);
        const outputFiles = [{ outputText: result.outputText, outputPath }];
        if (result.sourceMapText) {
            outputFiles.push({
                outputText: result.sourceMapText,
                outputPath: `${outputPath}.map`,
            });
        }
        const withDistDirs = this.concatDistDirIfNeeded(outputFiles);
        return withDistDirs;
    }
    concatDistDirIfNeeded(outputFiles) {
        if (!this.options.concatDistDir || !outputFiles) {
            return outputFiles;
        }
        const withDistDirs = outputFiles.map((outputFile) => {
            return {
                outputText: outputFile.outputText,
                outputPath: (0, normalize_path_1.default)(path_1.default.join(this.distDir, outputFile.outputPath)),
            };
        });
        return withDistDirs;
    }
    preBuild(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const capsules = context.capsuleNetwork.seedersCapsules;
            const capsuleDirs = capsules.map((capsule) => capsule.path);
            yield this.writeTsConfig(capsules, context.capsuleNetwork);
            yield this.writeTypes(capsuleDirs, context.envDefinition.id);
            yield this.writeNpmIgnore(capsuleDirs);
        });
    }
    /**
     * compile multiple components on the capsules
     */
    build(context) {
        return __awaiter(this, void 0, void 0, function* () {
            const componentsResults = yield this.runTscBuild(context.capsuleNetwork);
            return {
                artifacts: this.getArtifactDefinition(),
                componentsResults,
            };
        });
    }
    /**
     * The postBuild function processes and modifies .cjs files in the originalSeedersCapsules of the context's capsule
     * network.
     * It will remove the `export {};` statement from the end of the .cjs files.
     * As this is not valid JavaScript, it is necessary to remove this statement to ensure that the .cjs files can be used
     * as expected.
     * See: https://github.com/microsoft/TypeScript/issues/50647
     * Once this is merged into the TypeScript compiler, this function will no longer be necessary.
     * @param {BuildContext} context - The `context` parameter in the `postBuild` function seems to be of type
     * `BuildContext`. It is used to access information and perform actions related to the build process. In the provided
     * code snippet, the `postBuild` function is processing capsules in the `capsuleNetwork` of the context
     */
    postBuild(context) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all(context.capsuleNetwork.originalSeedersCapsules.map((capsule) => __awaiter(this, void 0, void 0, function* () {
                const distDir = path_1.default.join(capsule.path, this.distDir);
                const cjsFiles = yield (0, glob_1.glob)('**/*.cjs', { cwd: distDir });
                yield Promise.all(cjsFiles.map((cjsFile) => __awaiter(this, void 0, void 0, function* () {
                    const content = yield fs_extra_1.default.readFile(path_1.default.join(distDir, cjsFile), 'utf8');
                    const newContent = content.replace('export {};', '');
                    yield fs_extra_1.default.writeFile(path_1.default.join(distDir, cjsFile), newContent);
                })));
            })));
        });
    }
    getArtifactDefinition() {
        return [
            {
                generatedBy: this.id,
                name: this.artifactName,
                globPatterns: this.distGlobPatterns,
            },
        ];
    }
    /**
     * given a source file, return its parallel in the dists. e.g. index.ts => dist/index.js
     */
    getDistPathBySrcPath(srcPath) {
        const fileWithJSExtIfNeeded = this.replaceFileExtToJs(srcPath);
        return path_1.default.join(this.distDir, fileWithJSExtIfNeeded);
    }
    /**
     * whether typescript is able to compile the given path
     */
    isFileSupported(filePath) {
        const isJsAndCompile = !!this.options.compileJs && filePath.endsWith('.js');
        const isJsxAndCompile = !!this.options.compileJsx && filePath.endsWith('.jsx');
        const isSupported = (['.ts', '.tsx', '.mts', '.cts', '.mtsx', '.ctsx'].some((ext) => filePath.endsWith(ext)) ||
            isJsAndCompile ||
            isJsxAndCompile) &&
            !filePath.endsWith('.d.ts');
        return isSupported;
    }
    /**
     * we have two options here:
     * 1. pass all capsules-dir at the second parameter of createSolutionBuilder and then no
     * need to write the main tsconfig.json with all the references.
     * 2. write main tsconfig.json and pass the capsules root-dir.
     * we went with option #2 because it'll be easier for users to go to the capsule-root and run
     * `tsc --build` to debug issues.
     */
    runTscBuild(network) {
        return __awaiter(this, void 0, void 0, function* () {
            const rootDir = network.capsulesRootDir;
            const capsules = yield network.getCapsulesToCompile();
            if (!capsules.length) {
                return [];
            }
            const capsuleDirs = capsules.getAllCapsuleDirs();
            const componentsResults = [];
            let currentComponentResult = { errors: [] };
            const host = this.createHost(currentComponentResult);
            yield this.writeProjectReferencesTsConfig(rootDir, capsuleDirs);
            const solutionBuilder = this.tsModule.createSolutionBuilder(host, [rootDir], { verbose: true });
            let nextProject;
            const longProcessLogger = this.logger.createLongProcessLogger('compile typescript components', capsules.length);
            // the reason we use the "getNextInvalidatedProject()" way and not simply "build()" is that we want to log
            // per component. show the counter in the output and save the errors and execution time per component.
            // it's not possible to achieve this by running "build()", which simply builds all packages and only emits debug
            // and diagnostic messages.
            // eslint-disable-next-line no-cond-assign
            while ((nextProject = solutionBuilder.getNextInvalidatedProject())) {
                // const tsconfigName = this.getCapsuleTsConfigName();
                const capsulePath = (0, path_1.resolve)(nextProject.project, '..');
                // regex to make sure it will work correctly for both linux and windows
                // it replaces both /tsconfigName and \tsconfigName
                // const capsulePath = nextProject.project.replace(
                //   new RegExp(`[/\\\\]${tsconfigName}`),
                //   ''
                // );
                const currentComponentId = network.graphCapsules.getIdByPathInCapsule(capsulePath);
                if (!currentComponentId)
                    throw new Error(`unable to find component for ${capsulePath}`);
                longProcessLogger.logProgress(currentComponentId.toString());
                const capsule = network.graphCapsules.getCapsule(currentComponentId);
                if (!capsule)
                    throw new Error(`unable to find capsule for ${currentComponentId.toString()}`);
                currentComponentResult.component = capsule.component;
                currentComponentResult.startTime = Date.now();
                nextProject.done(undefined, undefined, this.options.typescriptTransformers);
                currentComponentResult.endTime = Date.now();
                componentsResults.push(Object.assign({}, currentComponentResult));
                currentComponentResult = { errors: [] };
            }
            longProcessLogger.end();
            if (!componentsResults.length) {
                // at this stage we know that our tsconfig.json contains capsules, so we expect componentsResults to be filled.
                // there are two reasons why this is not the case:
                // 1. all capsules are up to date.
                // 2. there was some error trying to get the packages to compile. for example, the tsconfig.json of the packages
                // have circular dependencies. (we already take care of this case and don't write the references, but just for the
                // case we missed something). in this case, `solutionBuilder.getNextInvalidatedProject()` returns undefined because
                // it has no package to compile. it doesn't throw an error. obviously, we it's not good for us. we want to know
                // that nothing was compiled. therefore, we run "build()", which is exactly the same as "tsc --build" in the
                // terminal.
                // anyway, those two cases are extremely rare, so we don't need to worry about performance.
                // in case the packages are already up to date, the "build()" won't do anything.
                solutionBuilder.build();
            }
            return componentsResults;
        });
    }
    getFormatDiagnosticsHost() {
        return {
            getCanonicalFileName: (p) => p,
            getCurrentDirectory: this.tsModule.sys.getCurrentDirectory,
            getNewLine: () => this.tsModule.sys.newLine,
        };
    }
    getDefaultGlobalTypes() {
        return (0, resolve_types_1.resolveTypes)(__dirname, ['global-types']);
    }
    writeTypes(dirs, envId) {
        return __awaiter(this, void 0, void 0, function* () {
            const types = this.options.types || this.getDefaultGlobalTypes();
            this.removeDuplicateTypes(envId);
            yield Promise.all(types.map((typePath) => __awaiter(this, void 0, void 0, function* () {
                const contents = yield fs_extra_1.default.readFile(typePath, 'utf8');
                const filename = path_1.default.basename(typePath);
                yield Promise.all(dirs.map((dir) => __awaiter(this, void 0, void 0, function* () {
                    const filePath = path_1.default.join(dir, 'types', filename);
                    if (!(yield fs_extra_1.default.pathExists(filePath))) {
                        yield fs_extra_1.default.outputFile(filePath, contents);
                    }
                })));
            })));
        });
    }
    removeDuplicateTypes(envId) {
        if (!this.options.types || !this.options.types.length)
            return;
        const filenames = this.options.types.map((typePath) => path_1.default.basename(typePath));
        const duplicatedFilenames = filenames.filter((filename, index) => filenames.indexOf(filename) !== index);
        if (!duplicatedFilenames.length)
            return;
        (0, lodash_1.uniq)(duplicatedFilenames).forEach((filename) => {
            this.options.types = this.options.types || [];
            const fullPaths = this.options.types.filter((typePath) => path_1.default.basename(typePath) === filename);
            this.logger.consoleWarning(`typescript compiler: found duplicated types file "${filename}", keeping the last one\n${fullPaths.join('\n')}`);
            const pathsToRemove = fullPaths.slice(0, fullPaths.length - 1); // keep only the last one
            this.options.types = this.options.types.filter((typePath) => !pathsToRemove.includes(typePath));
        });
        this.logger
            .consoleWarning(`the following files are written: ${this.options.types.join('\n')}
It's recommended to fix the env (${envId}) configuration to have only one file per type.`);
    }
    /**
     * when using project-references, typescript adds a file "tsconfig.tsbuildinfo" which is not
     * needed for the package.
     */
    writeNpmIgnore(dirs) {
        return __awaiter(this, void 0, void 0, function* () {
            const NPM_IGNORE_FILE = '.npmignore';
            const tsconfigName = this.getCapsuleTsConfigName();
            yield Promise.all(dirs.map((dir) => __awaiter(this, void 0, void 0, function* () {
                const tsconfigFiles = yield (0, glob_1.glob)('tsconfig.*.json', { cwd: dir });
                const npmIgnorePath = path_1.default.join(dir, NPM_IGNORE_FILE);
                const foundRootTsConfigEntries = tsconfigFiles.map((tsconfig) => `/${tsconfig}`);
                const npmIgnoreEntries = (0, lodash_1.uniq)([
                    `${this.distDir}/tsconfig.tsbuildinfo`,
                    `${this.distDir}/tsconfig.json`,
                    `${this.distDir}/${tsconfigName}`,
                    `/tsconfig.json`,
                    `/${tsconfigName}`,
                    ...foundRootTsConfigEntries,
                ]);
                let existingEntries = [];
                if (yield fs_extra_1.default.pathExists(npmIgnorePath)) {
                    existingEntries = (yield fs_extra_1.default.readFile(npmIgnorePath, 'utf8')).split('\n');
                }
                const filtered = (0, lodash_1.difference)(npmIgnoreEntries, existingEntries);
                const npmIgnoreEntriesStr = filtered ? `${filtered.join('\n')}\n` : '';
                yield fs_extra_1.default.appendFile(npmIgnorePath, npmIgnoreEntriesStr);
            })));
        });
    }
    writeProjectReferencesTsConfig(rootDir, projects) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = [];
            const references = projects.map((project) => {
                const projectPath = this.options.capsuleTsConfigName
                    ? path_1.default.join(project, this.options.capsuleTsConfigName)
                    : project;
                return { path: projectPath };
            });
            let tsconfig = { files, references };
            if (this.options.updateExistingProjectReferences) {
                const tsconfigPath = path_1.default.join(rootDir, 'tsconfig.json');
                if (yield fs_extra_1.default.pathExists(tsconfigPath)) {
                    const tsconfigStr = yield fs_extra_1.default.readFile(tsconfigPath, 'utf8');
                    tsconfig = JSON.parse(tsconfigStr);
                    if (tsconfig.references) {
                        tsconfig.references = tsconfig.references.concat(references);
                    }
                    else {
                        tsconfig.references = references;
                    }
                }
            }
            const tsconfigStr = this.stringifyTsconfig(tsconfig);
            yield fs_extra_1.default.writeFile(path_1.default.join(rootDir, 'tsconfig.json'), tsconfigStr);
        });
    }
    writeTsConfig(capsules, network) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!capsules.length)
                return [];
            const someCapsule = capsules[0];
            const hasGetDependenciesAPI = Boolean(someCapsule.component.getDependencies);
            // @ts-ignore this is a new API. Remove once deployed.
            const hasGetGraphIdsAPI = Boolean(capsules.getGraphIds);
            const writeTsConfigWithoutProjectReferences = () => __awaiter(this, void 0, void 0, function* () {
                const dirs = capsules.getAllCapsuleDirs();
                const tsconfigStr = this.stringifyTsconfig(this.rawTsConfig);
                yield Promise.all(dirs.map((dir) => fs_extra_1.default.writeFile(path_1.default.join(dir, 'tsconfig.json'), tsconfigStr)));
            });
            if (!hasGetDependenciesAPI || !hasGetGraphIdsAPI) {
                this.logger.consoleWarning(`typescript compiler: please update bit version to support references property in tsconfig.json`);
                return writeTsConfigWithoutProjectReferences();
            }
            // @ts-ignore this is a new API. Remove once deployed.
            const graph = capsules.getGraphIds();
            if (graph.isCyclic()) {
                this.logger
                    .consoleWarning(`typescript compiler: your capsules have circular dependencies, the optimization of Project Reference is disabled.
Please run "bit insights" to see the circular dependencies`);
                return writeTsConfigWithoutProjectReferences();
            }
            const idsPathsMap = {};
            const capsulesToCompile = yield network.getCapsulesToCompile();
            yield Promise.all(capsulesToCompile.map((current) => __awaiter(this, void 0, void 0, function* () {
                idsPathsMap[current.component.id.toString()] = current.path;
            })));
            const tsconfigName = this.getCapsuleTsConfigName();
            yield Promise.all(capsules.map((capsule) => __awaiter(this, void 0, void 0, function* () {
                const deps = capsule.component.getDependencies();
                const depsDirs = (0, lodash_1.compact)(deps.map((dep) => idsPathsMap[dep.id]));
                const customTsconfig = Object.assign({}, this.rawTsConfig);
                const paths = yield Promise.all(depsDirs.map((depDir) => __awaiter(this, void 0, void 0, function* () {
                    const tsconfigPath = path_1.default.join(depDir, 'tsconfig.json');
                    const exists = yield fs_extra_1.default.pathExists(tsconfigPath);
                    if (exists) {
                        return tsconfigPath;
                    }
                    // search fol all tsconfig files in the directory
                    const tsconfigFiles = yield (0, glob_1.glob)('**/tsconfig.*.json', {
                        cwd: depDir,
                    });
                    // If we found a tsconfig file, return it. Otherwise, return all tsconfig files in the directory
                    // This is usually happen when we have a compiler that compiles both to cjs and esm
                    // we want to reference for each config file to the corresponding tsconfig file
                    if (tsconfigFiles.includes(tsconfigName)) {
                        return path_1.default.join(depDir, tsconfigName);
                    }
                    return tsconfigFiles.map((tsconfigFile) => path_1.default.join(depDir, tsconfigFile));
                })));
                const flattenedPaths = (0, lodash_1.compact)(paths).flat();
                customTsconfig.references = flattenedPaths.map((p) => ({ path: p }));
                customTsconfig.compilerOptions = customTsconfig.compilerOptions || {};
                customTsconfig.compilerOptions.composite = true;
                yield fs_extra_1.default.writeFile(path_1.default.join(capsule.path, tsconfigName), this.stringifyTsconfig(customTsconfig));
            })));
            return undefined;
        });
    }
    getCapsuleTsConfigName() {
        return this.options.capsuleTsConfigName || 'tsconfig.json';
    }
    stringifyTsconfig(tsconfig) {
        return JSON.stringify(tsconfig, undefined, 2);
    }
    replaceFileExtToJs(filePath) {
        if (!this.isFileSupported(filePath))
            return filePath;
        const fileExtension = path_1.default.extname(filePath);
        // take into account mts, cts, mtsx, ctsx, etc.
        const replacement = fileExtension.replace(/([tj]sx?)$/, 'js');
        return filePath.replace(new RegExp(`${fileExtension}$`), replacement); // makes sure it's the last occurrence
    }
    version() {
        return this.tsModule.version;
    }
    static create(options, { logger }) {
        const name = options.name || 'typescript-compiler';
        const rawTsConfig = (0, get_ts_config_1.computeTsConfig)({
            tsconfig: options.tsconfig,
            compilerOptions: options.compilerOptions,
        });
        return new TypescriptCompiler(name, logger, options, rawTsConfig, options.typescript || typescript_1.default);
    }
    static from(options) {
        return (context) => {
            const name = options.name || 'typescript-compiler';
            const logger = context.createLogger(name);
            return TypescriptCompiler.create(options, { logger });
        };
    }
}
exports.TypescriptCompiler = TypescriptCompiler;
//# sourceMappingURL=typescript-compiler.js.map