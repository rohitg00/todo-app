import { CompilerOptions as TsCompilerOptions, CustomTransformers } from 'typescript';
import type { CompilerOptions } from '@teambit/compiler';
import { TsConfigTransformer } from '@teambit/typescript';
export type TypeScriptCompilerOptions = {
    /**
     * path to tsconfig to use during compilation.
     */
    tsconfig?: string;
    /**
     * a compiler options object.
     */
    compilerOptions?: TsCompilerOptions;
    /**
     * path for .d.ts files to include during build.
     */
    types?: string[];
    /**
     * Run the compiler for .js files. this will only affect whether to run the compiler on the files
     * or not. It won't change the tsconfig to support or not support js files.
     */
    compileJs?: boolean;
    /**
     * Run the compiler for .js files. this will only affect whether to run the compiler on the files
     * or not. It won't change the tsconfig to support or not support jsx files.
     */
    compileJsx?: boolean;
    /**
     * By default when setting the tsconfig to have
     * "moduleResolution": "NodeNext",
     * "module": "NodeNext"
     * TS will check the closest package.json to determine if it should emit ESM to CJS outputs.
     * Since in bit we don't have a package.json usually, TS will just emit CJS
     * This option will force TS to emit ESM
     */
    esm?: boolean;
    /**
     * instance of typescript to use.
     */
    typescript?: any;
    /**
     * array of tsconfig transformers to apply.
     */
    transformers?: TsConfigTransformer[];
    /**
     * array of transpilation transformers to apply.
     */
    typescriptTransformers?: CustomTransformers;
    /**
     * if this is set to true, the compiler files results will set the outputPath with the dist dir provided
     * for example
     * {
     *  outputPath: 'dist/my-file.js'
     * }
     */
    concatDistDir?: boolean;
    /**
     * name of the tsconfig to use when running the compiler on the capsules.
     * this will:
     * 1. write the tsconfig in the capsule using that name.
     * 2. on the tsoncfig on the capsule root reference that tsconfig. (instead of referencing the capsule dir)
     * 3. write that tsconfig file name on the npmignore file.
     */
    capsuleTsConfigName?: string;
    /**
     * If this is true, when creating the tsconfig in the root of the capsule, we will update the references
     * instead of creating a new one.
     * This is useful when using multiple ts compilers on the same capsule.
     * If you are not sure you need it, keep it false.
     */
    updateExistingProjectReferences?: boolean;
} & Partial<CompilerOptions>;
export type TsCompilerOptionsWithoutTsConfig = Omit<TypeScriptCompilerOptions, 'tsconfig'>;
