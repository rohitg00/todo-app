import { relative, resolve, sep } from 'path';
import fsExtra from 'fs-extra';
import minimatch from 'minimatch';
import lodash from 'lodash';
import { Tests, } from '@teambit/tester';
import { TestsFiles, TestResult, TestsResult } from '@teambit/tests-results';
import { ComponentMap } from '@teambit/component';
import { mergeConfig, loadConfigFromFile } from 'vite';
import { VitestError } from './vitest-error.js';
const { compact, flatten, isEmpty } = lodash;
const { existsSync, writeJSONSync } = fsExtra;
// pattern utils
const resolvePattern = (pattern, rootDirs) => {
    return rootDirs.map((dir) => resolve(dir, pattern));
};
const resolvePatternEntry = (patternEntry) => {
    const { componentDir, paths } = patternEntry;
    return paths.map((p) => {
        if (p.relative.startsWith('!')) {
            return `!${componentDir}${p.relative.slice(1)}`;
        }
        return resolve(componentDir, p.path);
    });
};
const resolveComponentPattern = (component, patternEntry, opts, context) => {
    if (opts.resolveSpecPaths) {
        return opts.resolveSpecPaths(component, context);
    }
    const customPatterns = opts.patterns;
    // If pattern were provided to the specific instance of the tester, use them
    if (customPatterns && !isEmpty(customPatterns)) {
        customPatterns.map((customPattern) => {
            const rootDirs = opts.roots || [patternEntry.componentDir];
            return resolvePattern(customPattern, rootDirs);
        });
    }
    const resolvedPatterns = resolvePatternEntry(patternEntry);
    return resolvedPatterns;
};
const getPatternsMap = (opts, context) => {
    const target = opts.useDistsInCapsules
        ? context.patterns
        : (context.sourcePatterns || context.patterns);
    return target;
};
// input utils
export const patternsToArray = (opts, context) => {
    const patternsMap = getPatternsMap(opts, context);
    const patternArray = flatten(patternsMap
        .toArray()
        .map(([component, patternEntry]) => resolveComponentPattern(component, patternEntry, opts, context)));
    if (sep === '\\') {
        return patternArray.map((pattern) => pattern.replace(/\\/g, '/'));
    }
    return patternArray;
};
const ensurePackageJson = (dir) => {
    const packageJsonPath = resolve(dir, 'package.json');
    if (!existsSync(packageJsonPath)) {
        writeJSONSync(packageJsonPath, {});
    }
};
const getCoverageInclude = (context, workspace) => {
    if (!workspace)
        return undefined;
    return context.components.map(c => {
        const componentDir = workspace.componentDir(c.id);
        return relative(context.rootPath, componentDir);
    });
};
export const getExclude = (opts) => {
    // https://vitest.dev/config/#exclude default value without dist
    const excludeWithoutDist = [
        '**/node_modules/**',
        '**/cypress/**',
        '**/.{idea,git,cache,output,temp}/**',
        '**/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*'
    ];
    return opts.useDistsInCapsules ? excludeWithoutDist : undefined;
};
export const getConfig = async (configPath, context, workspace, depResolver, watch) => {
    const packageNames = context.components.map((component) => depResolver.getPackageName(component));
    // TODO: remove this once we have a better way to handle this
    ensurePackageJson(context.rootPath);
    const config = {
        root: context.rootPath,
        configFile: false,
        envFile: false,
        plugins: [],
        server: {
            fs: {
                strict: false
            },
            watch: {
                ignored: packageNames.map((m) => `!**/node_modules/${m}/**`),
            }
        },
        // https://sass-lang.com/d/legacy-js-api
        css: {
            preprocessorOptions: {
                scss: {
                    api: 'modern-compiler'
                }
            }
        },
        cacheDir: resolve(context.rootPath, 'node_modules', '.vitest'),
        test: {
            globals: true,
            environment: 'jsdom',
            root: context.rootPath,
            testTimeout: 10000,
            css: {
                modules: {
                    // set this as default since the relative file paths in workspaces and capsules are different
                    classNameStrategy: 'non-scoped'
                }
            },
            server: {
                deps: {
                    // @ts-ignore
                    // web: {
                    //   transformCss: true,
                    //   transformAssets: true
                    // },  
                    inline: [/^(?!.*vitest).*$/],
                }
            },
        }
    };
    if (context.debug) {
        // Nothing to do with Vitest
    }
    if (context.coverage) {
        config.test.coverage = {
            provider: 'v8',
            enabled: true,
            include: getCoverageInclude(context, workspace),
        };
    }
    config.test.watch = context.watch || watch;
    const vitestConfig = await loadConfigFromFile({
        command: 'build',
        mode: 'development'
    }, configPath);
    const realVitestConfig = vitestConfig?.config || {};
    const result = mergeConfig(config, realVitestConfig);
    return result;
};
// output utils
const getTaskState = (status) => {
    switch (status) {
        case 'pass':
            return 'passed';
        case 'fail':
            return 'failed';
        case 'skip':
            return 'skipped';
        case 'todo':
            return 'todo';
        default:
            return 'pending';
    }
};
const traverseTask = (task, ancestor = []) => {
    const resultList = [];
    const errorList = [];
    const info = {
        resultList,
        pass: 0,
        failed: 0,
        pending: 0,
        duration: 0,
        slow: false, // TODO: calculate slow
        errorList,
    };
    if (task.type === 'test') {
        const error = task.result?.errors?.[0];
        const errorStr = error?.message || error?.stack;
        const status = getTaskState(task.result?.state);
        switch (status) {
            case 'passed':
                info.pass += 1;
                break;
            case 'failed':
                info.failed += 1;
                break;
            case 'pending':
                info.pending += 1;
                break;
            default:
                break;
        }
        const isFailure = status === 'failed';
        info.duration += task.result?.duration || 0;
        resultList.push(new TestResult(ancestor, task.name, status, task.result?.duration, isFailure ? undefined : errorStr, isFailure ? errorStr : undefined));
    }
    if (task.type === 'suite') {
        errorList.push(...(task.result?.errors || []));
        task.tasks.forEach(subTask => {
            const subInfo = traverseTask(subTask, [...ancestor]);
            info.pass += subInfo.pass;
            info.failed += subInfo.failed;
            info.pending += subInfo.pending;
            info.duration += subInfo.duration;
            info.slow = info.slow || subInfo.slow;
            resultList.push(...subInfo.resultList);
            errorList.push(...subInfo.errorList);
        });
    }
    return info;
};
const genErrorsFromTests = (files, unhandledErrors) => {
    const errors = [];
    files.forEach(file => {
        file.tests.forEach(test => {
            if (test.error) {
                errors.push(new VitestError(test.error));
            }
            if (test.failure) {
                errors.push(new VitestError(test.failure));
            }
        });
    });
    unhandledErrors.forEach((error) => {
        errors.push(error);
    });
    return errors;
};
export const getResultFromFiles = (files, errors, opts, context) => {
    const patternsMap = getPatternsMap(opts, context);
    const componentMap = ComponentMap.as(patternsMap.components, (component) => {
        const componentPatternValue = patternsMap.get(component);
        if (!componentPatternValue)
            return [];
        const [currComponent, patternEntry] = componentPatternValue;
        const resolvedPatterns = resolveComponentPattern(currComponent, patternEntry, opts, context);
        return files.filter(file => resolvedPatterns.filter((resolvedPattern) => minimatch(file.filepath, resolvedPattern)).length > 0);
    });
    const componentResults = componentMap.toArray().map(([component, componentFiles]) => {
        const componentPatternValue = patternsMap.get(component);
        if (!componentPatternValue)
            return undefined;
        const [, patternEntry] = componentPatternValue;
        const tests = [];
        const fileErrors = [];
        componentFiles.forEach(file => {
            const { pass, failed, pending, duration, slow, resultList, errorList, } = traverseTask(file);
            let fileError;
            if (errorList.length > 0) {
                fileError = new Error(errorList.map(e => e.stackStr || '').join('\n'));
                fileErrors.push(fileError);
            }
            tests.push(new TestsFiles(relative(patternEntry.componentDir, file.filepath), resultList, pass, failed, pending, duration, slow, fileError));
        });
        const totalErrors = genErrorsFromTests(tests, [...errors, ...fileErrors]);
        return {
            componentId: component.id,
            results: new TestsResult(tests, totalErrors.length === 0, 0),
            errors: totalErrors,
        };
    });
    const result = compact(componentResults);
    return new Tests(result);
};
//# sourceMappingURL=utils.js.map