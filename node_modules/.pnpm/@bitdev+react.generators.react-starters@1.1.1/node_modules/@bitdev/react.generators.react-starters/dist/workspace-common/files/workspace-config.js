"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.workspaceConfig = workspaceConfig;
const config_1 = require("@teambit/config");
const comment_json_1 = require("comment-json");
const constants_1 = require("../constants");
async function workspaceConfig({ name, defaultScope, aspectComponent }, extraConfig, additionalEnvs = []) {
    const scope = defaultScope || constants_1.DEFAULT_SCOPE;
    const envId = aspectComponent.id.toStringWithoutVersion();
    /**
     * a ws that was generated by the react-env should use the forked env
     */
    const generatorEnv = envId === 'teambit.react/react-env' ? `${scope}/${constants_1.FORKED_ENV_NAME}` : envId;
    const configParsed = await (0, config_1.getWorkspaceConfigTemplateParsed)();
    configParsed['teambit.workspace/workspace'].name = name;
    configParsed['teambit.workspace/workspace'].defaultScope = scope;
    configParsed["teambit.workspace/workspace"].resolveEnvsFromRoots = true;
    configParsed['teambit.dependencies/dependency-resolver'].packageManager =
        'teambit.dependencies/pnpm';
    configParsed['teambit.dependencies/dependency-resolver'].rootComponents =
        true;
    configParsed['teambit.dependencies/dependency-resolver'].policy = {
        dependencies: {
        // eslint: '^7.28.0',
        },
    };
    configParsed['teambit.generator/generator'] = {
        envs: [generatorEnv, ...additionalEnvs],
    };
    delete configParsed['teambit.workspace/variants'];
    const configMerged = extraConfig
        ? (0, comment_json_1.assign)(configParsed, extraConfig)
        : configParsed;
    return (0, config_1.stringifyWorkspaceConfig)(configMerged);
}
//# sourceMappingURL=workspace-config.js.map